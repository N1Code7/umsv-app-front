import { Dispatch, FormEvent, SetStateAction, useContext, useRef, useState } from "react";
import { ValidationError } from "yup";
import { mutate } from "swr";
import { IUser } from "../../../interfaces/interfaces";
import Switch from "../../components/Switch";
import { userSchema } from "../../../validations/userSchema";
import { AuthenticationContext } from "../../../contexts/AuthenticationContext";
import useAxiosPrivateMultipart from "../../../hooks/useAxiosPrivateMultipart";

interface IProps {
  patchMethod?: boolean;
  focusedUser?: IUser;
  isModalActive?: boolean;
  setIsModalActive?: Dispatch<SetStateAction<boolean>>;
  setRequestMessage: Dispatch<SetStateAction<{ success: string; error: string }>>;
}

interface IFormErrors {
  lastName: string;
  firstName: string;
  email: string;
  roles: string;
  gender: string;
  birthDate: string;
  state: string;
  validatedAccount: string;
}

const UserForm = ({
  patchMethod,
  focusedUser,
  setRequestMessage,
  isModalActive,
  setIsModalActive,
}: IProps) => {
  //
  const axiosPrivateMultipart = useAxiosPrivateMultipart();
  const { user } = useContext(AuthenticationContext);
  const firstNameRef = useRef<HTMLInputElement>(null);
  const lastNameRef = useRef<HTMLInputElement>(null);
  const emailRef = useRef<HTMLInputElement>(null);
  // const { rolesRef } = useRef<HTMLInputElement>(null);
  const genderRef = useRef<HTMLSelectElement>(null);
  const birthDateRef = useRef<HTMLInputElement>(null);
  const stateRef = useRef<HTMLSelectElement>(null);
  const validatedAccountRef = useRef<HTMLInputElement>(null);
  const [userTypeSelected, setUserTypeSelected] = useState("");
  const [validatedAccount, setValidatedAccount] = useState(focusedUser?.validatedAccount || false);
  const [formErrors, setFormErrors] = useState({} as IFormErrors);

  /** Validation of form fields before fetch the post route */
  const handleSubmitForm = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    let errors = {} as IFormErrors;

    /** Body of post request */
    const bodyRequest = {
      lastName: lastNameRef.current!.value,
      firstName: firstNameRef.current!.value,
      email: emailRef.current!.value,
      passwordAutoGenerated: true,
      roles: user?.roles.includes("ROLE_ADMIN")
        ? userTypeSelected === "admin"
          ? ["ROLE_ADMIN", "ROLE_MEMBER"]
          : ["ROLE_MEMBER"]
        : undefined,
      // roles: rolesRef.current?.value || ["ROLE_MEMBER"],
      gender: genderRef.current?.value || undefined,
      birthDate: birthDateRef.current?.value || undefined,
      state: stateRef.current?.value || "inactive",
      validatedAccount: validatedAccountRef.current?.checked || false,
    };

    await userSchema
      .validate(bodyRequest, { abortEarly: false })
      .then(async () => {
        isModalActive && setIsModalActive?.(false);
        if (!patchMethod) {
          await mutate(
            "/admin/users",
            await axiosPrivateMultipart
              .post(
                user?.roles.includes("ROLE_SUPERADMIN")
                  ? "/admin/user/admin"
                  : "/admin/user/member",
                bodyRequest
              )
              .then((res) => {
                setRequestMessage({
                  error: "",
                  success: `Le compte utilisateur de ${focusedUser?.firstName?.toUpperCase()} a bien √©t√© cr√©√© ! üëå`,
                });
                return res.data;
              })
              .catch((err) => {
                console.error(err);
                setRequestMessage({
                  error: `Une erreur est survenue lors de la cr√©ation du compte utilisateur de ${focusedUser?.firstName?.toUpperCase()} ü§ï.`,
                  success: "",
                });
              }),
            {
              optimisticData: (all: Array<IUser>) =>
                [...all, bodyRequest as IUser].sort(
                  (a: IUser, b: IUser) =>
                    Number(new Date(b.updatedAt || b.createdAt)) -
                    Number(new Date(a.updatedAt || a.createdAt))
                ),
              populateCache: (result: IUser, current: Array<IUser>) => [...current, result],
            }
          );
        } else {
          await mutate(
            "/admin/users",
            await axiosPrivateMultipart
              .patch(
                user?.roles.includes("ROLE_SUPERADMIN")
                  ? `/admin/user/admin/${focusedUser?.id}`
                  : `/admin/user/member${focusedUser?.id}`,
                bodyRequest
              )
              .then((res) => {
                setRequestMessage({
                  error: "",
                  success: `Le compte utilisateur de ${focusedUser?.firstName?.toUpperCase()} a bien √©t√© modifi√© ! üëå`,
                });
                return res.data;
              })
              .catch((err) => {
                console.error(err);
                setRequestMessage({
                  error: `Une erreur est survenue lors de la modification du compte utilisateur de ${focusedUser?.firstName?.toUpperCase()}`,
                  success: "",
                });
              }),
            {
              optimisticData: (all: Array<IUser>) => {
                const prev = all.filter((item: IUser) => item.id !== focusedUser?.id);
                return [...prev, { ...focusedUser, ...bodyRequest } as IUser].sort(
                  (a: IUser, b: IUser) =>
                    Number(new Date(b.updatedAt || b.createdAt)) -
                    Number(new Date(a.updatedAt || a.createdAt))
                );
              },
              populateCache: (result: IUser, current: Array<IUser>) => {
                const prev = current.filter((item: IUser) => item.id !== focusedUser?.id);
                return [...prev, result];
              },
              rollbackOnError: true,
              revalidate: false,
            }
          );
        }
        setTimeout(() => {
          setRequestMessage({ success: "", error: "" });
        }, 10000);
        window.scrollTo(0, 0);
      })
      .catch((err) => {
        err.inner.forEach(
          (err: ValidationError) => (errors = { ...errors, [err.path as string]: err.message })
        );
      });

    setFormErrors(errors);
  };

  return (
    <form className="form registration-form" onSubmit={handleSubmitForm}>
      <div className="form-row">
        <label htmlFor="userLastName">Nom de l&apos;utilisateur</label>
        {formErrors.lastName && <div className="form-error-detail">{formErrors.lastName}</div>}
        <input
          type="text"
          id="userLastName"
          className={formErrors.lastName ? "form-error" : undefined}
          autoFocus
          defaultValue={focusedUser?.lastName || undefined}
          ref={lastNameRef}
        />
      </div>

      <div className="form-row">
        <label htmlFor="userFirstName">Pr√©nom de l&apos;utilisateur</label>
        {formErrors.firstName && <div className="form-error-detail">{formErrors.firstName}</div>}
        <input
          type="text"
          id="userFirstName"
          className={formErrors.firstName ? "form-error" : undefined}
          defaultValue={focusedUser?.firstName || undefined}
          ref={firstNameRef}
        />
      </div>

      <div className="form-row">
        <label htmlFor="userEmail">Email de l&apos;utilisateur</label>
        {formErrors.email && <div className="form-error-detail">{formErrors.email}</div>}
        <input
          type="email"
          id="userEmail"
          className={formErrors.email ? "form-error" : undefined}
          defaultValue={focusedUser?.email || undefined}
          ref={emailRef}
        />
      </div>

      {user?.roles.includes("ROLE_SUPERADMIN") && (
        <div className="form-row">
          <label>Type d&apos;utilisateur</label>
          <div className="radio-container">
            <div>
              <input
                type="radio"
                name="userType"
                id="adminType"
                checked={userTypeSelected === "admin" ? true : false}
                onChange={() => setUserTypeSelected("admin")}
              />
              <label htmlFor="adminType">Admin</label>
            </div>
            <div>
              <input
                type="radio"
                name="userType"
                id="memberType"
                checked={userTypeSelected === "member" ? true : false}
                onChange={() => setUserTypeSelected("member")}
              />
              <label htmlFor="memberType">Membre</label>
            </div>
          </div>
        </div>
      )}

      <div className="form-row">
        <label htmlFor="userGender">Genre de l&apos;utilisateur</label>
        {formErrors.gender && <div className="form-error-detail">{formErrors.gender}</div>}
        <select
          id="userGender"
          className={formErrors.gender ? "form-error" : undefined}
          defaultValue={focusedUser?.gender || undefined}
          ref={genderRef}
        >
          <option value="male">Masculin</option>
          <option value="female">F√©minin</option>
        </select>
      </div>

      <div className="form-row">
        <label htmlFor="userBirthDate">Date de naissance de l&apos;utilisateur</label>
        {formErrors.birthDate && <div className="form-error-detail">{formErrors.birthDate}</div>}
        <input
          type="date"
          id="userBirthDate"
          className={formErrors.gender ? "form-error" : undefined}
          defaultValue={focusedUser?.birthDate}
          ref={birthDateRef}
        />
      </div>

      <div className="form-row">
        <label htmlFor="userState">√âtat du compte de l&apos;utilisateur</label>
        {formErrors.birthDate && <div className="form-error-detail">{formErrors.birthDate}</div>}
        <select
          id="userState"
          className={formErrors.gender ? "form-error" : undefined}
          defaultValue={focusedUser?.state}
          ref={stateRef}
        >
          <option value="pending">En attente</option>
          <option value="active">Activ√©</option>
          <option value="inactive">D√©sactiv√©</option>
        </select>
      </div>

      <div className="form-row">
        <label>Validation du compte</label>
        <div className="switch-identifier">
          <span style={{ cursor: "pointer" }} onClick={() => setValidatedAccount(false)}>
            Non valide
          </span>
          <Switch
            customName="toggle-active"
            isActive={validatedAccount}
            setIsActive={setValidatedAccount}
          />
          <span style={{ cursor: "pointer" }} onClick={() => setValidatedAccount(true)}>
            Valid√©
          </span>
        </div>
      </div>

      {/* {!chooseNewUser ? (
        <div className="form-row">
          <label htmlFor="selectUser">S√©lectionner un utilisateur existant</label>
          {formErrors.registrationSelectUser && (
            <div className="form-error-detail">{formErrors.registrationSelectUser}</div>
          )}
          <select
            id="selectUser"
            ref={registrationSelectUser}
            className={formErrors.registrationSelectUser ? "form-error" : undefined}
            defaultValue={focusedRegistration?.user?.id || "null"}
            autoFocus
            required
          >
            <option value="null">---</option>
            {usersLoading
              ? "Chargement..."
              : !users
              ? "Aucun utilisateur"
              : users
                  // .filter((user: IUser) => user.validatedAccount)
                  .sort((a: IUser, b: IUser) => a.lastName.localeCompare(b.lastName))
                  .map((user: IUser) => (
                    <option key={user.id} value={user.id}>
                      {`${user.lastName.toUpperCase()} ${user.firstName}`}
                    </option>
                  ))}
          </select>
        </div>
      ) : (
        <>
          <div className="form-row">
            <label htmlFor="userLastName">Nom du joueur</label>
            {formErrors.registrationUserLastName && (
              <div className="form-error-detail">{formErrors.registrationUserLastName}</div>
            )}
            <input
              type="text"
              id="userLastName"
              className={formErrors.registrationUserLastName ? "form-error" : ""}
              autoFocus
              defaultValue={focusedRegistration?.userLastName || undefined}
              ref={registrationUserLastName}
            />
          </div>
          <div className="form-row">
            <label htmlFor="userFirstName">Pr√©nom du joueur</label>
            {formErrors.registrationUserFirstName && (
              <div className="form-error-detail">{formErrors.registrationUserFirstName}</div>
            )}
            <input
              type="text"
              id="userFirstName"
              className={formErrors.registrationUserFirstName ? "form-error" : ""}
              defaultValue={focusedRegistration?.userFirstName || undefined}
              ref={registrationUserFirstName}
            />
          </div>
          <div className="form-row">
            <label htmlFor="userEmail">Email du joueur</label>
            {formErrors.registrationUserEmail && (
              <div className="form-error-detail">{formErrors.registrationUserEmail}</div>
            )}
            <input
              type="text"
              id="userEmail"
              className={formErrors.registrationUserEmail ? "form-error" : ""}
              defaultValue={focusedRegistration?.userEmail || undefined}
              ref={registrationUserEmail}
            />
          </div>
        </>
      )}

      <div className="form-row choose-tournament-identifier">
        <span onClick={() => setChooseNewTournament(false)} style={{ cursor: "pointer" }}>
          Tournoi existant
        </span>
        <Switch
          customName="toggle-form"
          isActive={chooseNewTournament}
          setIsActive={setChooseNewTournament}
        />
        <span onClick={() => setChooseNewTournament(true)} style={{ cursor: "pointer" }}>
          Nouveau tournoi
        </span>
      </div>

      {!chooseNewTournament ? (
        <div className="form-row">
          <label htmlFor="selectTournament">S√©lectionner un tournoi existant</label>
          {formErrors.registrationSelectTournament && (
            <div className="form-error-detail">{formErrors.registrationSelectTournament}</div>
          )}
          <select
            id="selectTournament"
            ref={registrationSelectTournament}
            className={formErrors.registrationSelectTournament ? "form-error" : ""}
            defaultValue={focusedRegistration?.tournament?.id || selectedTournament?.id || "null"}
            autoFocus
            required
          >
            <option value="null">---</option>
            {tournamentsLoading
              ? "Chargement..."
              : !tournaments
              ? "Aucun tournoi"
              : tournaments
                  .filter(
                    (tournament: ITournament) =>
                      (tournament.randomDraw &&
                        new Date(tournament.randomDraw).getTime() - new Date().getTime() > -10) ||
                      tournament.id === focusedRegistration?.tournament?.id
                  )
                  .sort(
                    (a: ITournament, b: ITournament) =>
                      Number(new Date(a.startDate)) - Number(new Date(b.startDate))
                  )
                  .map((tournament: ITournament) => (
                    <option key={tournament.id} value={tournament.id}>
                      {tournament.name?.slice(0, 20) + "..." || "‚ÑπÔ∏è"} - {tournament.city} -{" "}
                      {tournament.endDate
                        ? formatDate(
                            String(tournament.startDate),
                            String(tournament.endDate),
                            "XX & XX xxx XXXX"
                          )
                        : formatDate(String(tournament.startDate), undefined, "XX xxx XXXX")}
                    </option>
                  ))}
          </select>
        </div>
      ) : (
        <>
          <div className="form-row">
            <label htmlFor="tournamentName">Nom du tournoi</label>
            {formErrors.registrationName && (
              <div className="form-error-detail">{formErrors.registrationName}</div>
            )}
            <input
              type="text"
              id="tournamentName"
              className={formErrors.registrationName ? "form-error" : ""}
              autoFocus
              defaultValue={focusedRegistration?.tournamentName || undefined}
              ref={registrationName}
            />
          </div>
          <div className="form-row">
            <label htmlFor="tournamentCity">Ville du tournoi</label>
            {formErrors.registrationCity && (
              <div className="form-error-detail">{formErrors.registrationCity}</div>
            )}
            <input
              type="text"
              id="tournamentCity"
              className={formErrors.registrationCity ? "form-error" : ""}
              ref={registrationCity}
              defaultValue={focusedRegistration?.tournamentCity || undefined}
              required
            />
          </div>
          <div className="form-row">
            {formErrors.registrationStartDate && (
              <div className="form-error-detail">{formErrors.registrationStartDate}</div>
            )}
            {formErrors.registrationEndDate && (
              <div className="form-error-detail">{formErrors.registrationEndDate}</div>
            )}
            <div className="dates">
              <label htmlFor="startDate">Du </label>
              <input
                type="date"
                id="startDate"
                ref={registrationStartDate}
                min={formatDate(new Date().toISOString(), undefined, "XXXX-XX-XX")}
                defaultValue={
                  (focusedRegistration?.tournamentStartDate &&
                    formatDate(
                      focusedRegistration?.tournamentStartDate,
                      undefined,
                      "XXXX-XX-XX"
                    )) ||
                  undefined
                }
                required
              />
              <label htmlFor="endDate"> au </label>
              <input
                type="date"
                id="endDate"
                ref={registrationEndDate}
                min={
                  registrationStartDate.current?.value
                    ? formatDate(
                        new Date(
                          new Date(registrationStartDate.current?.value!).setDate(
                            new Date(registrationStartDate.current?.value!).getDate() + 1
                          )
                        ).toISOString(),
                        undefined,
                        "XXXX-XX-XX"
                      )
                    : undefined
                }
                defaultValue={
                  (focusedRegistration?.tournamentEndDate &&
                    formatDate(focusedRegistration?.tournamentEndDate, undefined, "XXXX-XX-XX")) ||
                  undefined
                }
              />
            </div>
          </div>
        </>
      )}

      <div className="checkboxes-container">
        {formErrors.checkboxes && <div className="form-error-detail">{formErrors.checkboxes}</div>}
        <div className="checkboxes">
          <div className="form-row">
            <input
              type="checkbox"
              name="single"
              id="single"
              ref={checkboxSingle}
              defaultChecked={focusedRegistration?.participationSingle || false}
            />
            <label htmlFor="single">Simple</label>
          </div>

          <div className="form-row">
            <input
              type="checkbox"
              name="double"
              id="double"
              defaultChecked={focusedRegistration?.participationDouble || false}
              onChange={() => setCheckboxDouble((prev) => !prev)}
            />
            <label htmlFor="double">Double</label>
          </div>
          <div className="form-row">
            <input
              type="checkbox"
              name="mixed"
              id="mixed"
              defaultChecked={focusedRegistration?.participationMixed || false}
              onChange={() => setCheckboxMixed((prev) => !prev)}
            />
            <label htmlFor="mixed">Mixte</label>
          </div>
        </div>
      </div>

      {checkboxDouble && (
        <div className="form-row">
          <label htmlFor="doublePartner">Partenaire de Double</label>
          <div className="partner-container">
            <input
              type="text"
              id="doublePartner"
              placeholder="NOM / Pr√©nom | Laisser vide si X"
              ref={registrationDoublePartnerName}
              defaultValue={focusedRegistration?.doublePartnerName || undefined}
            />
            <input
              type="text"
              placeholder="Club"
              ref={registrationDoublePartnerClub}
              defaultValue={focusedRegistration?.doublePartnerClub || undefined}
            />
          </div>
        </div>
      )}

      {checkboxMixed && (
        <div className="form-row">
          <label htmlFor="mixedPartner">Partenaire de mixte</label>
          <div className="partner-container">
            <input
              type="text"
              id="mixedPartner"
              placeholder="NOM / Pr√©nom | Laisser vide si X"
              ref={registrationMixedPartnerName}
              defaultValue={focusedRegistration?.mixedPartnerName || undefined}
            />
            <input
              type="text"
              placeholder="Club"
              ref={registrationMixedPartnerClub}
              defaultValue={focusedRegistration?.mixedPartnerClub || undefined}
            />
          </div>
        </div>
      )}

      <div className="form-row">
        <label htmlFor="comments">Commentaires</label>
        {formErrors.comment && <div className="form-error-detail">{formErrors.comment}</div>}
        <textarea
          id="comments"
          cols={30}
          rows={5}
          className={formErrors.comment ? "form-error" : ""}
          ref={registrationComment}
          defaultValue={focusedRegistration?.comment || undefined}
        ></textarea>
      </div> */}

      <input
        type="submit"
        value={(patchMethod ? "Modifier" : "Cr√©er") + " la demande d'inscription"}
        className="btn btn-primary"
      />
    </form>
  );
};

export default UserForm;
